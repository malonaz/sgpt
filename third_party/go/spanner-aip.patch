diff --git a/spanfiltering/transpile.go b/spanfiltering/transpile.go
index 5770db6..b7e33d4 100644
--- a/spanfiltering/transpile.go
+++ b/spanfiltering/transpile.go
@@ -1,14 +1,13 @@
 package spanfiltering
 
 import (
-	"cloud.google.com/go/spanner/spansql"
 	"go.einride.tech/aip/filtering"
 )
 
 // TranspileFilter transpiles a parsed AIP filter expression to a spansql.BoolExpr, and
 // parameters used in the expression.
 // The parameter map is nil if the expression does not contain any parameters.
-func TranspileFilter(filter filtering.Filter) (spansql.BoolExpr, map[string]interface{}, error) {
+func TranspileFilter(filter filtering.Filter) (string, []interface{}, error) {
 	var t Transpiler
 	t.Init(filter)
 	return t.Transpile()
diff --git a/spanfiltering/transpiler.go b/spanfiltering/transpiler.go
index 1be28fc..d4dd8fa 100644
--- a/spanfiltering/transpiler.go
+++ b/spanfiltering/transpiler.go
@@ -3,8 +3,8 @@ package spanfiltering
 import (
 	"fmt"
 	"strconv"
-	"strings"
 	"time"
+	"strings"
 
 	"cloud.google.com/go/spanner/spansql"
 	"go.einride.tech/aip/filtering"
@@ -13,36 +13,41 @@ import (
 	"google.golang.org/protobuf/reflect/protoregistry"
 )
 
+const (
+	FunctionIsNull = "ISNULL"
+	FunctionJSONB = "JSONB"
+	jsonbStartPlaceholder = "__jsonb__"
+)
+
 type Transpiler struct {
 	filter       filtering.Filter
-	params       map[string]interface{}
+	params       []interface{}
 	paramCounter int
 }
 
 func (t *Transpiler) Init(filter filtering.Filter) {
 	*t = Transpiler{
 		filter: filter,
-		params: make(map[string]interface{}),
+		params: []interface{}{},
 	}
 }
 
-func (t *Transpiler) Transpile() (spansql.BoolExpr, map[string]interface{}, error) {
+func (t *Transpiler) Transpile() (string, []interface{}, error) {
 	if t.filter.CheckedExpr == nil {
-		return spansql.True, nil, nil
+		return "", nil, nil
 	}
 	resultExpr, err := t.transpileExpr(t.filter.CheckedExpr.GetExpr())
 	if err != nil {
-		return nil, nil, err
+		return "", nil, err
 	}
 	resultBoolExpr, ok := resultExpr.(spansql.BoolExpr)
 	if !ok {
-		return nil, nil, fmt.Errorf("not a bool expr")
+		return "", nil, fmt.Errorf("not a bool expr")
 	}
 	params := t.params
-	if t.paramCounter == 0 {
-		params = nil
-	}
-	return resultBoolExpr, params, nil
+	sql := "WHERE " + strings.ReplaceAll(resultBoolExpr.SQL(), "@_param_", "$")
+	sql = strings.ReplaceAll(sql, "@" + jsonbStartPlaceholder, "")
+	return sql, params, nil
 }
 
 func (t *Transpiler) transpileExpr(e *expr.Expr) (spansql.Expr, error) {
@@ -109,6 +114,10 @@ func (t *Transpiler) transpileCallExpr(e *expr.Expr) (spansql.Expr, error) {
 		return t.transpileNotCallExpr(e)
 	case filtering.FunctionTimestamp:
 		return t.transpileTimestampCallExpr(e)
+	case FunctionIsNull:
+		return t.transpileIsNullCallExpr(e)
+	case FunctionJSONB:
+		return t.transpileJSONBCallExpr(e)
 	default:
 		return nil, fmt.Errorf("unsupported function call: %s", e.GetCallExpr().GetFunction())
 	}
@@ -236,6 +245,110 @@ func (t *Transpiler) transpileSubstringMatchExpr(e *expr.Expr) (spansql.BoolExpr
 	}, nil
 }
 
+type NullComparison struct {field string}
+func (c *NullComparison) SQL() string {
+	return fmt.Sprintf("(%s IS NULL)", c.field)
+}
+
+func (t *Transpiler) transpileIsNullCallExpr(
+	e *expr.Expr,
+) (spansql.BoolExpr, error) {
+	callExpr := e.GetCallExpr()
+	if len(callExpr.Args) != 1 {
+		return nil, fmt.Errorf(
+			"unexpected number of arguments to `%s`: %d",
+			callExpr.GetFunction(),
+			len(callExpr.Args),
+		)
+	}
+	lhs, err := t.transpileExpr(callExpr.Args[0])
+	if err != nil {
+		return nil, err
+	}
+	return spansql.IsOp{
+		LHS: lhs,
+		RHS: spansql.NullLiteral(0),
+	}, nil
+}
+
+func (t *Transpiler) transpileJSONBCallExpr(
+	e *expr.Expr,
+) (spansql.Expr, error) {
+	callExpr := e.GetCallExpr()
+	if len(callExpr.Args) != 1 {
+		return nil, fmt.Errorf(
+			"unexpected number of arguments to `%s`: %d",
+			callExpr.GetFunction(),
+			len(callExpr.Args),
+		)
+	}
+	// Extract the field expression, which is assumed to be a JSON string literal.
+	jsonPathExpr, err := t.transpileExpr(callExpr.Args[0])
+	if err != nil {
+		return nil, err
+	}
+
+	// Determine the expected type from the type map
+	exprType, ok := t.filter.CheckedExpr.TypeMap[e.Id]
+	if !ok {
+		return nil, fmt.Errorf("unknown type of JSONB expr %d", e.Id)
+	}
+
+
+	// Determine if we need type casting
+	needsCast := true
+	var castType string
+
+	primitive := exprType.GetPrimitive()
+	switch primitive {
+	case expr.Type_STRING:
+		needsCast = false // strings use ->> operator
+	case expr.Type_BOOL:
+		castType = "boolean"
+	case expr.Type_INT64:
+		castType = "bigint"
+	case expr.Type_UINT64:
+		castType = "bigint" // PostgreSQL doesn't have unsigned types
+	case expr.Type_DOUBLE:
+		castType = "double precision"
+	default:
+		// fallback to string.
+		// Note: protobuf timestamps get marshaled as string in json.
+		needsCast = false
+	}
+
+
+	var sb strings.Builder
+	split := strings.Split(jsonPathExpr.SQL(), "@")
+	if len(split) < 1 {
+		return nil, fmt.Errorf("jsonpath path needs at least one value")
+	}
+	sb.WriteString(jsonbStartPlaceholder)
+	if needsCast {
+		sb.WriteString("(")
+	}
+	sb.WriteString(split[0])
+
+	// Build the JSON path expression
+	for i := 1; i < len(split); i++ {
+		// Use -> for intermediate levels, ->> for final level (string extraction)
+		if i < len(split)-1 {
+			sb.WriteString("->")
+		} else {
+			sb.WriteString("->>")
+		}
+		sb.WriteString("'" + split[i] + "'")
+	}
+
+	// Add type cast if needed
+	if needsCast {
+		sb.WriteString(")::")
+		sb.WriteString(castType)
+	}
+
+	return spansql.Param(sb.String()), nil
+}
+
 func (t *Transpiler) transpileBinaryLogicalCallExpr(
 	e *expr.Expr,
 	op spansql.LogicalOperator,
@@ -334,12 +447,12 @@ func (t *Transpiler) transpileTimestampCallExpr(e *expr.Expr) (spansql.Expr, err
 
 func (t *Transpiler) param(param interface{}) spansql.Param {
 	p := t.nextParam()
-	t.params[p] = param
+	t.params = append(t.params, param)
 	return spansql.Param(p)
 }
 
 func (t *Transpiler) nextParam() string {
-	param := "param_" + strconv.Itoa(t.paramCounter)
+	param := "_param_" + strconv.Itoa(t.paramCounter +1)
 	t.paramCounter++
 	return param
 }
diff --git a/spanordering/transpile.go b/spanordering/transpile.go
index 3a23ba3..46794ce 100644
--- a/spanordering/transpile.go
+++ b/spanordering/transpile.go
@@ -8,22 +8,24 @@ import (
 )
 
 // TranspileOrderBy transpiles a valid ordering.OrderBy expression to a spansql.Order expression.
-func TranspileOrderBy(orderBy ordering.OrderBy) []spansql.Order {
+func TranspileOrderBy(orderBy ordering.OrderBy) string {
 	if len(orderBy.Fields) == 0 {
-		return nil
+		return ""
 	}
-	result := make([]spansql.Order, 0, len(orderBy.Fields))
+	result := make([]string, 0, len(orderBy.Fields))
 	for _, field := range orderBy.Fields {
 		subFields := strings.Split(field.Path, ".")
 		if len(subFields) == 1 {
-			result = append(result, spansql.Order{Expr: spansql.ID(subFields[0]), Desc: field.Desc})
+			result = append(result, spansql.Order{Expr: spansql.ID(subFields[0]), Desc: field.Desc}.SQL())
 			continue
 		}
 		pathExp := make(spansql.PathExp, 0, len(subFields))
 		for _, subField := range subFields {
 			pathExp = append(pathExp, spansql.ID(subField))
 		}
-		result = append(result, spansql.Order{Expr: pathExp, Desc: field.Desc})
+		result = append(result, spansql.Order{Expr: pathExp, Desc: field.Desc}.SQL())
 	}
-	return result
+
+	str := "ORDER BY " + strings.Join(result, ", ")
+	return str
 }
